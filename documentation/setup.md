
- [Repository Setup](#repository-setup)
  - [Install the Gem](#install-the-gem)
  - [Create deploy.yml](#create-deployyml)
  - [Create Kubernetes manifests in kubernetes/](#create-kubernetes-manifests-in-kubernetes)
  - [Directory structure](#directory-structure)
- [Jenkins Job Setup](#jenkins-job-setup)
  - [Java Projects](#java-projects)
    - [Jenkinsfiles Integration](#jenkinsfiles-integration)
    - [Removing Deprecated pom.xml Integration](#removing-deprecated-pomxml-integration)
    - [Further Java References](#further-java-references)
  - [Non-Java projects](#non-java-projects)
    - [Jenkins UI build steps](#jenkins-ui-build-steps)
      - [(1) The Jenkins build should run on Docker-enabled Jenkins workers.](#1-the-jenkins-build-should-run-on-docker-enabled-jenkins-workers)
      - [(2) Jenkins credentials are required for Github auth on `docker2` machines below.](#2-jenkins-credentials-are-required-for-github-auth-on-docker2-machines-below)
      - [(3) Jenkins credentials are required to publish your project's images to AWS ECR](#3-jenkins-credentials-are-required-to-publish-your-projects-images-to-aws-ecr)

# Repository Setup

The instructions below describe how to set up kube_deploy_tools in any generic
project build. Note that instructions are specified for Java projects where applicable.

After setup, see [documentation/deploy.md](deploy.md) for deploying your
project manually and setting up your Pentagon deploy.

## Install the Gem

Install the `kube_deploy_tools` gem in your project (or Java module)
by adding a Gemfile.

Gemfile:
```ruby
source 'https://gemserver.***REMOVED***'

group :kdt do
  gem 'kube_deploy_tools', '~> 2.0'
end
```

```bash
bundle install --with kdt --without default development test
```

## Create deploy.yml

Add a deploy.yml to your project (or Java module).

```bash
cat << EOF > deploy.yml
deploy:
  clusters:
    - target: local
      environment: staging
      flags:
        cloud: local
        image_registry: local-registry
        pull_policy: IfNotPresent
        image_tag: latest
    - target: colo-service
      environment: prod
      flags:
        cloud: colo
        image_registry: ***REMOVED***
        pull_policy: IfNotPresent
    - target: colo-service
      environment: staging
      flags:
        cloud: colo
        image_registry: ***REMOVED***
        pull_policy: IfNotPresent
  flavors:
    default: {}
EOF
```

Edit deploy.yml to only include the Kubernetes clusters where your project
runs e.g. be specific and choose colo and/or AWS.

For a full list of supported clusters, see
[examples/projects/deploy.yml](../examples/project/deploy.yml).

## Create Kubernetes manifests in kubernetes/

Use the `kubernetes/` directory for storing your Kubernetes manifests
in your project (or Java module).

File types can either be `.yaml` or `.yaml.erb`, and files may be stored into
subdirectories. For example:

```
kubernetes/
  configmap-my-todo-list.yaml
  my-todo-app/
    dep-my-todo-app.yaml.erb
    service-my-todo-app.yaml
```

See [documentation/kube_manifests_with_erb.md](kube_manifests_with_erb.md)
for writing Kubernetes manifests with ERB.

The manifests in the `kubernetes/` directory will be rendered by
`kube_deploy_tools` into the `build/kubernetes/` directory, where deploy
artifacts will be compressed and published to Artifactory.

Thus, add the `build/` directory to your .gitignore file.

## Directory structure

```
my-project/
  Gemfile                       # contains gem 'kube_deploy_tools'
  Gemfile.lock
  deploy.yml                    # deployment config for your project
  kubernetes/
  build/kubernetes/             # don't commit this directory, it's generated by kube_deploy_tools
  .gitignore                    # the build/ directory is git ignored
```

# Jenkins Job Setup

Jenkins job steps are required
1. to build, tag, and push all of your Docker images, and
2. to render and push all Kubernetes manifests.

These KDT commands are required to run at the end of your Jenkins job.

```bash
# In your project's Jenkins build script

# Build images
docker build -t local-registry/<image> # for each Docker image in your project
# Push images to image registry
bundle exec kdt publish_container --registry=<registry> <images...> # for all Docker images built in your project
# Render Kubernetes deploy artifacts
bundle exec kdt render_deploys
# Push Kubernetes deploy artifacts to Artifactory
bundle exec kdt publish_artifacts
```

For Java projects, see the Jenkinsfile setup below, which will run the commands above.

For non-Java projects, include these KDT commands and see the non-Java project setup below.

## Java Projects

### Jenkinsfiles Integration
1. See steps in [MasterRepos/jenkins_pipelines](https://git.***REMOVED***/MasterRepos/jenkins_pipelines/blob/master/README.md) to add a Jenkinsfile to your repository

Note: The project name in the KDT deploy will change from using the Jenkinsfile. The new name will be `project=MasterRepos/${repository}/${branch_name}`.
This can be found at the top of the Jenkins job that was run for the desired build.


Cross reference the KB page
[Jenkinsfiles](https://liveramp.atlassian.net/wiki/spaces/CI/pages/138249012/Jenkinsfiles)

### Removing Deprecated pom.xml Integration

1. Run `bundle update` in the root directory of the project
2. Follow the steps in [MasterRepos/jenkins_pipelines](https://git.***REMOVED***/MasterRepos/jenkins_pipelines/blob/master/README.md) to add a Jenkinsfile to your repository
3. In all the pom.xmls within the project remove any occurence of the below:

```diff
-    <skip.kdt.docker>false</skip.kdt.docker>
-    <skip.kdt.kubernetes>false</skip.kdt.kubernetes>
-    <docker.images>${project.artifactId}</docker.images>
```

4. If it is a multi-module project:
   * In the root directory, run the following
   ```bash
     mv *_kubernetes/kubernetes .
     mv *_kubernetes/Gemfile .
     rm -rf *_kubernetes
   ```
   * In pom.xml remove any references to the `*_kubernetes` module
   * Now the structure of the root directory and files should mimic that of a single module repository
5. Run `bundle install` to verify

### Further Java References

Cross reference the KB page
[Migrating Backend Applications to Kubernetes](https://liveramp.atlassian.net/wiki/spaces/CI/pages/98096573/Migrating+Backend+Applications+to+Kubernetes)
with `java_project_tools`, or `jpt`.

## Non-Java projects

### Jenkins UI build steps
Below are Jenkins build steps required for configuration in the Jenkins UI.

For examples of Jenkins configurations, see below.
* [ingestion_file_locator](https://jenkins.***REMOVED***/job/ingestion_file_locator/configure)
* [ingestion_file_locator_prs](https://jenkins.***REMOVED***/job/ingestion_file_locator_prs/configure)

#### (1) The Jenkins build should run on Docker-enabled Jenkins workers.
* Under General > Restrict where this project can be run,
set the Label Expression to `docker2`.

#### (2) Jenkins credentials are required for Github auth on `docker2` machines below.
* Under Credentials > Source Code Management > Git, select `rapleaf (RSA,  github)`.

#### (3) Jenkins credentials are required to publish your project's images to AWS ECR
and your project's deploy artifacts to Artifactory. See the image below and instructions.

![Jenkins Artifactory upload](jenkins_build.png)

* Under Build Environment, check Use secret text(s) or file(s).
* Under Bindings, select username and password (separated) with
`AWS_ACCESS_KEY_ID` as the Username Variable,
`AWS_SECRET_ACCESS_KEY` as the Password Variable, and
`.../****** (AWS svc-jenkins-docker credentials for ECR)` selected as the specific
credentials. See above.
* Under Bindings, select username and password (separated) with
`ARTIFACTORY_USERNAME` as the Username Variable,
`ARTIFACTORY_PASSWORD` as the Password Variable, and
`jenkins_publisher/****** (***REMOVED***)` selected as the specific
credentials. See above.
