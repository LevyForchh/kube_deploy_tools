#!/usr/bin/env ruby
#
# Run from the root of a repository. |deploy.json| is expected to exist there.
# Generates all deploys based on permutations defined in deploy.yml combined
# with cluster configuration from kube_deploy_tools.

require 'erb'
require 'yaml'

require 'cluster_config'

DEFAULT_HOOK_SCRIPT_NAME = 'render_deploys_hook'
MANIFEST_FILE = 'deploy.yml'

class RenderDeploys
  def initialize(manifest, output_dir)
    unless File.file?(manifest)
      raise "Can't read deploy manifest: #{manifest}"
    end

    @project = ENV['JOB_ID'] || File.basename(`git config remote.origin.url`.chomp, '.git')
    @build_number = ENV['BUILD_ID'] || DateTime.now.strftime('%Y%m%d%H%M%S')

    @output_dir = output_dir
    FileUtils.rm_rf @output_dir
    FileUtils.mkdir_p @output_dir

    @manifest = YAML.load(File.read(manifest)).fetch('deploy')
  end

  def render
    clusters = @manifest.fetch('clusters')
    flavors = @manifest.fetch('flavors')

    # Sanity check.
    unless clusters.size > 0
      raise 'Must support deployment to at least one cluster'
    end

    unless flavors.size > 0
      raise 'Must support at least one flavor (try "_default": {})'
    end

    # Build environmental flags.
    git_sha1 = `git rev-parse --short=7 HEAD`.chomp
    root_flags = {
      'image_tag' => git_sha1,
      'tag' => git_sha1,
      'username' => Etc.getlogin
    }

    clusters.each do |c|
      target = c.fetch('target')
      env = c.fetch('environment')

      # Get metadata for this target/environment pair.
      cluster = CLUSTERS.fetch(target).fetch(env)
      cluster_flags = root_flags.clone

      cluster_flags.update('target': target, 'environment': env)
      cluster_flags.merge!(render_erb_flags(cluster['flags']))
      cluster_flags.merge!(render_erb_flags(c['extra_flags'])) if c['extra_flags']

      flavors.reject { |key, value| !(c['flavors'].nil? or c['flavors'].include? key) }.each do |flavor, flavor_flags|
        full_flags = cluster_flags.clone
        full_flags.merge!(render_erb_flags(flavor_flags)) if flavor_flags

        # Save rendered release configuration to a temp file.
        rendered = Tempfile.new('deploy_config')
        rendered << YAML.dump(full_flags)
        rendered.flush

        # Call individual templating hook with the rendered configuration
        # and a prefix to place all the files.
        flavor_dir = File.join(@output_dir, target, env, flavor)
        FileUtils.mkdir_p flavor_dir

        # TODO(joshk): Run in parallel.
        call_hook(rendered.path, flavor_dir)

        # Pack up contents of each flavor_dir to a correctly named artifact tarball.
        tarball = "manifests_#{@project}_#{@build_number}_#{target}_#{env}_#{flavor}.tar.gz"
        tarball_full_path = File.join(@output_dir, tarball)
        check_call(['tar', '-C', flavor_dir, '-czf', tarball_full_path, '.'])
        puts "generated manifest archive: #{tarball_full_path}"
      end
    end
  end

  def call_hook(config, output)
    # Retrieve hook definition.
    hook = @manifest['hook_script'] || File.join(File.dirname(__FILE__), DEFAULT_HOOK_SCRIPT_NAME)
    check_call([hook, config, output])
  end

  def render_erb_flags(flags)
    result = Hash.new

    flags.each do |key, template|
      renderer = ERB.new(template)
      result[key] = renderer.result
    end

    result
  end

  def check_call(cmd)
    ok = system(*cmd)
    raise "Failed to run #{cmd}: exit status #{$?}" unless ok
  end
end

# TODO(joshk): Make each of these customizable
app = RenderDeploys.new(MANIFEST_FILE, File.expand_path('pkg'))
app.render
