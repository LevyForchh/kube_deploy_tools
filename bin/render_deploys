#!/usr/bin/env ruby
#
# Run from the root of a repository. |deploy.json| is expected to exist there.
# Generates all deploys based on permutations defined in deploy.json combined
# with cluster configuration from kube_deploy_tools.

require 'erb'
require 'json'
require 'yaml'

require 'cluster_config'

DEFAULT_HOOK_SCRIPT_NAME = 'render_deploys_hook'
MANIFEST_FILE = 'deploy.json'

class RenderDeploys
  def initialize(manifest, output_dir)
    unless File.file?(manifest)
      raise "Can't read deploy manifest: #{manifest}"
    end

    @output_dir = output_dir
    FileUtils.rm_rf @output_dir
    FileUtils.mkdir_p @output_dir

    @manifest = JSON.parse(File.read(manifest)).fetch('deploy')
  end

  def render
    clusters = @manifest.fetch('clusters')
    flavors = @manifest.fetch('flavors')

    # Sanity check.
    unless clusters.size > 0
      raise 'Must support deployment to at least one cluster'
    end

    unless flavors.size > 0
      raise 'Must support at least one flavor (try "_default": {})'
    end

    # Build environmental flags.
    git_sha1 = `git rev-parse --short=7 HEAD`.chomp
    root_flags = {
      'image_tag' => git_sha1,
      'tag' => git_sha1,
      'username' => Etc.getlogin
    }

    clusters.each do |c|
      target = c.fetch('target')
      env = c.fetch('environment')

      # Get metadata for this target/environment pair.
      cluster = CLUSTERS.fetch(target).fetch(env)
      cluster_flags = root_flags.clone

      cluster_flags.update('target': target, 'environment': env)
      cluster_flags.merge! render_erb_flags(cluster['flags'])
      cluster_flags.merge! render_erb_flags(c['extra_flags']) if c['extra_flags']

      flavors.each do |flavor, flavor_flags|
        full_flags = cluster_flags.clone
        full_flags.merge(render_erb_flags(flavor_flags)) if flavor_flags

        # Save rendered release configuration to a temp file.
        rendered = Tempfile.new('deploy_config')
        rendered << YAML.dump(full_flags)
        rendered.flush

        # Call individual templating hook with the rendered configuration
        # and a prefix to place all the files.
        flavor_dir = File.join(@output_dir, target, env, flavor)
        FileUtils.mkdir_p flavor_dir

        # TODO(joshk): Run in parallel.
        call_hook(rendered.path, flavor_dir)
      end
    end
  end

  def call_hook(config, output)
    # Retrieve hook definition.
    hook = @manifest['hook_script'] || File.join(File.dirname(__FILE__), DEFAULT_HOOK_SCRIPT_NAME)
    cmd = [hook, config, output]
    ok = system(*cmd)
    raise "Failed to run #{cmd}: exit status #{$?}" unless ok
  end

  def render_erb_flags(flags)
    result = Hash.new

    flags.each do |key, template|
      renderer = ERB.new(template)
      result[key] = renderer.result
    end

    result
  end
end

app = RenderDeploys.new('deploy.json', File.expand_path('pkg'))
app.render
