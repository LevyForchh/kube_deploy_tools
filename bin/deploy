#!/usr/bin/env ruby
# Utility for applying Kubernetes manifests.

require 'tmpdir'

require 'kube_deploy_tools/deploy_artifact'
require 'kube_deploy_tools/formatted_logger'
require 'kube_deploy_tools/kubectl'
require 'kube_deploy_tools/shellrunner'
require 'kube_deploy_tools/deploy'
require 'kube_deploy_tools/deploy/options'

def options
  parser = KubeDeployTools::Deploy::Optparser.new
  ops = parser.parse(ARGV)
  ops
end

KubeDeployTools::Logger.logger = KubeDeployTools::FormattedLogger.build
KubeDeployTools::Shellrunner.shellrunner = KubeDeployTools::Shellrunner.new
context = options.context || KubeDeployTools.kube_context(target: options.target, environment: options.environment)
namespace = KubeDeployTools::Deploy::kube_namespace(context: context)
KubeDeployTools::Logger.logger = KubeDeployTools::FormattedLogger.build(context: context, namespace: namespace)
kubectl = KubeDeployTools::Kubectl.new(
  context: options.context,
  kubeconfig: options.kubeconfig,
)

Dir.mktmpdir { |tmpdir|
  if options.from_files
    deploy_artifact_path = KubeDeployTools::DeployArtifact.new(
      input_path: options.from_files,
    ).path
  else
    deploy_artifact_path = KubeDeployTools::DeployArtifact.new(
      input_path: KubeDeployTools.get_remote_deploy_artifact_url(
        project: options.project,
        build_number: options.build_number,
        target: options.target,
        environment: options.environment,
        flavor: options.flavor,
      ),
      output_dir_path: tmpdir,
      pre_apply_hook: options.pre_apply_hook
    ).path
  end

  deploy = KubeDeployTools::Deploy.new(
    kubectl: kubectl,
    namespace: namespace,
    input_path: deploy_artifact_path,
    glob_files: options.glob_files,
  )
  deploy.run(
    dry_run: options.dry_run,
  )
}

